# 1. Linux Command Line

## 1.1. 什么是shell

shell是一个程序，它接受从键盘输入的命令，然后把命令传递给操作系统去执行。
bash是来自GNU项目的shell程序。
bash是“Bourne Again Shell”的首字母缩写。
bash是最初Unix上由Steve Bourne写成shell程序sh的增强版。

## 1.2. shell技巧

移动光标：借助上箭头按键获得上次输入的命令.借助左右按键把光标定位到命令行的任意位置。
tab：tab按键具有文件/目录/命令的补全功能。

## 1.3. shell命令

* date     日期
* cal      日历
* df       查看磁盘剩余空间。
* free     查看空闲内存。
* exit     退出shell。
* pwd      打印当前目录名。
* ls       列出目录内容
* .        指工作目录
* ..       指工作目录的父目录
* cd       更改目录
* cd -     更改目录到先前的目录
* cd ~user_name    更改工作目录到用户家目录.
    注:linux对大小写敏感且没有文件扩展名的概念.文件名支持标点符号仅限使用"."和"-"及"_".
* file    当调用file命令后，file命令会打印出文件内容的简单描述。
* less    用来浏览文本文件的程序.

## 1.4. linux系统中的目录

* /       根目录,万物之源.
* /bin    包含系统启动和运行所必须的二进制程序.
* /boot   包含Linux内核,最初的RMA磁盘映像和启动加载程序.
    /boot/grub/grub.conf or menu.lst,用来配置启动加载程序.
    /boot/vmlinuz,linux内核
* /dev    包含设备节点的特殊目录."一切皆是文件",也适用于设备.内核维护着它的支持设备.
* /etc    包含所有系统层面的配置文件.同时也包含一系列的shell脚本,在系统启动时,这些脚本会运行每个系统服务.这个目录中的任何文件都应该是可读文本文件.
    /etc/crontab,定义自动运行的任务.
    /etc/fstab,包含存储设备的列表及相关挂载点.
    /etc/passwd,包含用户账号列表.
* /home   系统会在/home下,为每个用户分配一个工作目录.
* /lib    包含核心系统程序所需的库文件.类似windows中的动态链接库.
* /lost+found 每个使用linux文件系统的格式化分区或设备,都会有这个目录.当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录是空的，除非文件系统损坏。
* /media    包含可移动介质的挂载点。
* /mnt    早些的系统中，/mnt目录包含可以东介质的挂载点。
* /opt    用来安装“可选”软件。用来存储可能安装在系统中的商业软件产品。
* /proc   是一个由Linux内核维护的虚拟文件系统。它包含的文件是内核的窥视孔。这些可读的文件告诉你内核是怎样监管你的计算机的。
* /root   root账户的家目录。
* /sbin   包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。
* /tmp    用来存储由各种程序创建的临时文件的地方。
* /usr    包含普通用户所需要的所有程序和文件。
    /usr/bin    包含系统安装的执行程序。
    /usr/lib    包含/usr/bin目录中的程序所用的共享库。
    /usr/local  非系统发行版自带程序的安装目录。通常由源码编译的程序会安装在/usr/local/bin目录下。
    /usr/sbin   包含许多系统管理程序。
    /usr/share  包含许多由/usr/bin目录中的程序使用的共享数据。其中包括默认的配置文件、图表、桌面北京、音频文件等等。
    /usr/share/doc  包含安装在系统中的软件包的文档。
* /var    存放的是动态文件。各种数据库，假脱机文件，用户邮件等等。
    /var/log    包含日至文件、各种系统活动的记录。其中/var/log/messages很重要。

## 1.5. 符号链接

创建硬链接   ln  当创建文件硬链接，实际是为文件创建了额外的名字部分，并且名字关联到相同的数据部分。硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。
创建符号链接   ln -s  创建符号链接既可以使用绝对路径也可以使用相对路径名。符号链接可以关联目录。

## 1.6. 命令的使用

    命令的四种形式：
        1.可执行程序.
        2.内建于shell自身的命令.
        3.shell函数.
        4.命令别名.自定义自己的命令,尖子在其他命令之上.

## 1.7. 命令的识别

type    type command    shell的内部命令,它会显示命令的类别.
which   确定所执行程序的准确位置.只对可执行程序有效,不包括内建命令和命令别名.

## 1.8. 命令的文档

### 1.8.1. help

得到shell内建命令的帮助文档.bash有一个内建的帮助工具.
--help  很多执行程序支持一个--help选项,这个想象是显示命令所支持的语法和选项说明.

### 1.8.2. man

man program(program是要浏览的命令名)     显示程序手册页.许多可执行程序提供了一个正式的文档,叫做手册页(man page).

### 1.8.3. apropos

显示适当的命令.
注意:man命令加上"-k"选项与apropos完成一样的功能.

### 1.8.4. whatis  显示非常简介的命令说明

### 1.8.5. info

显示程序Info条目.GNU项目提供了一个命令程序手册页的替代五,称其为"info".

### 1.8.6. README和其它程序文档

   位于/usr/share/doc目录下的文本文件,可用less阅读器来浏览.以".gz"结尾的文件是用gzip压缩程序压缩的.gzip软件包包含了一个特殊的less版本,叫做zless,可以显示由gzip压缩的文本文件内容.

### 1.8.7. 创建自己的命令

command1;command2;command3...
    例: cd /usr; ls; cd -
首先使用type 检测"command name"是否被使用.通过   alias foo='cd /usr;ls/cd -'来创建命令.
使用  unalias foo 命令来删除创建的foo命令.

## 1.9. 重定向

I/O重定向."I/O"代表输入/输出,通过此工具可以重定向命令的输入输出,命令输入输出均来自文件.也可以把多个命令联结起来组成强大的命令管道.

### 1.9.1. shell命令

* cat     连接文件.
                例:cat movie.mpeg.0* > movie.mpeg    因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。
* sort    排序文本行
* uniq    报道或省略重复行
* grep    打印匹配行
* wc      打印文件中换行符,字和字节个数.
* head    输出文件第一部分
* tail    输出文件最后一部分
* tee     从标准输入读取数据并写道标准输出和文件.
许多程序都会产生某种输出.经常由两种类型组成.

1. 程序运行结果.
2. 状态和错误信息.

    I/O重定向允许我们梗概输出地点和输入来源.一般输入来自键盘,输出送到屏幕.通过I/O重定向,我们可以改变.
    shell将文件流的前三个称作标准输入,标准输出和错误,称为表述副0,1,2.

### 1.9.2. 标准输出重定向

* >   > filename  将标准输出重定向到除屏幕意外的另一个文件.例:ls -l /bin/usr >ls-output.txt
* > text.txt  没有命令在它之前,这回清空同名的文件内容或创建空文件.
* >> filename 将重定向结果追加到文件内容或后面.

### 1.9.3. 标准错误重定向

例:ls -l /bin/usr 2>ls-error.txt 文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务。

#### 1.9.3.1. 重定向标准输出和错误到同一文件

* 方法一:
    例:ls -l /bin/usr > ls-output.txt 2>&1   首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2>&1。重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。
* 方法二:
    例:ls -l /bin/usr &> ls-output.txt   用单单一个表示法 &> 来重定向标准输出和错误到文件 ls-output.txt。

#### 1.9.3.2. 处理不需要的输出

系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。
    例:ls -l /bin/usr 2> /dev/null

### 1.9.4. 标准输入重定向

* 例:cat > lazy_dog.txt
    The quick brown fox jumped over the lazy dog.

    输入命令，其后输入要放入文件中的文本。输入 Ctrl-d（按住 Ctrl 键同时按下”d”），来告诉 cat，在标准输入中， 它已经到达文件末尾（EOF）.通过使用这个命令，我们 实现了世界上最低能的文字处理器！

* 例:cat < lazy_dog.txt
    使用"<"重定向操作符,把标准输入源从键盘改到文件lazy_dog.txt.

#### 1.9.4.1. 管道线

* |    command1 | command2    使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入.
    例:ls -l /usr/bin | less

#### 1.9.4.2. 过滤器

管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。

例:ls /bin /usr/bin | sort | less

因为我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个有序列表。

#### 1.9.4.3. uniq

报道或忽略重复行

默认情况下，从数据列表中删除任何重复行。uniq 命令经常和 sort 命令结合在一起使用。

例:ls /bin /usr/bin | sort | uniq | less  

使用 uniq 从 sort 命令的输出结果中，来删除任何重复行。如果我们想看到 重复的数据列表，让 uniq 命令带上”-d”选项.

### 1.9.5. wc

打印行数,字数和字节数

wc命令是用来显示文件所包含的行数,字数和字节数.它接受标准输入。”-l”选项限制命令输出只能 报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。

### 1.9.6. grep

grep pattern [file...]  打印匹配行

用来找到文件中的匹配文本。grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。

### 1.9.7. head / tail

打印文件开头部分/结尾部分.
head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。

tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为 它们同时在被写入。使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。

### 1.9.8. tee

从 Stdin 读取数据，并同时输出到 Stdout 和文件

tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。

    例:ls /usr/bin | tee ls.txt | grep zip
在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt.

## 1.10. 从shell眼中看世界

### 1.10.1. 字符展开

* echo    显示一行文本。传递到 echo 命令的任一个参数都会在（屏幕上）显示出来。
* echo *  ”*“字符意味着匹配文件名中的任意字符，shell 在 echo 命 令被执行前把”*“展开成了另外的东西（在这里，就是在当前工作目录下的文件名字）。

### 1.10.2. 路径名展开

echo ls -d .[!.]?*

  这种模式展开成所有以圆点开头，第二个字符不包含圆点，再包含至少一个字符， 并且这个字符之后紧接着任意多个字符的文件名。这个命令将正确列出大多数的隐藏文件 （但仍不能包含以多个圆点开头的文件名）。带有 -A 选项（“几乎所有”）的 ls 命令能够提供一份正确的隐藏文件清单：ls -A

### 1.10.3. 波浪线展开

波浪线字符"~"有特殊的含义.当用在一个单词的开头时,它会展开成制定用户的家目录名,如果没有制定用户名,则展开成当前用户的家目录.

### 1.10.4. 算术表达式展开
$((expression))

（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。

算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。在算术表达式中空格并不重要，并且表达式可以嵌套。

### 1.10.5. 花括号展开

花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一系列的整数，或者单个的字符串。这种模式不能 嵌入空白字符。

    例:echo Number_{1..5}    echo {A..Z}
    echo Front-{A,B,C}-Back
    花括号展开可以嵌套：echo a{A{1,2},B{3,4}}b
    用花括号展开创建一系列文件/目录

    例:mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}

### 1.10.6. 参数展开

它的许多功能和系统存储小块数据，并给每块数据命名的能力有关系。许多像这样的小块数据， 更恰当的称呼应该是变量，可供你方便地检查它们。

    例:  echo $USER
    要查看有效的变量列表,使用   printenv | less

### 1.10.7. 命令替换

命令替换允许我们把一个命令的输出作为一个展开模式来使用.

    例:  echo $(ls)  ls -l $(which cp)   file $(ls -l /usr/bin/* |grep zip)

在bash中,也可以使用另一种语法---使用倒引号替代美元符号和括号.     ls -l `which cp`

### 1.10.8. 引用

shell 提供了一种 叫做引用的机制，来有选择地禁止不需要的展开。

#### 1.10.8.1. 双引号

如果你把文本放在双引号中， shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割、路径名展开、 波浪线展开和花括号展开都将失效，然而参数展开、算术展开和命令替换 仍然执行。

    例:  ls -l "two words.txt"
        echo "this is a    test"
在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。这意味着无引用的空格，制表符和换行符都不是文本的一部分， 它们只作为分隔符使用。
    echo "this is a   test"
    单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分。 一旦加上双引号，我们的命令行就包含一个带有一个参数的命令。

事实上，单词分割机制把换行符看作界定符，对命令替换产生了一个虽然微妙但有趣的影响。echo \$(cal)与echo "\$(cal)".在第一个实例中，没有引用的命令替换导致命令行包含38个参数。在第二个例子中， 命令行只有一个参数，参数中包括嵌入的空格和换行符。

#### 1.10.8.2. 单引号

如果需要禁止所有的展开，我们要使用单引号。

#### 1.10.8.3. 转义字符

有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。注意在单引号中，反斜杠失去它的特殊含义，它 被看作普通字符.

使用转义字符来消除文件名中一个字符的特殊含义
    .mv bad\$filename good_filename.

反斜杠除了作为转义字符外，也可以构成一种表示法，来代表某种 特殊字符，这些特殊字符叫做控制码。ASCII 编码表中前32个字符被用来把命令转输到电报机 之类的设备。一些编码是众所周知的（制表符，退格符，换行符，和回车符），而其它 一些编码就不熟悉了（空值，传输结束码，和确认）。
* \a    响铃（”警告”－导致计算机嘟嘟响）
* \b    退格符
* \n    新的一行。在类 Unix 系统中，产生换行。
* \r    回车符
* \t    制表符
这种利用反斜杠的表示法背后的思想来源于 C 编程语言， 许多其它语言也采用了这种表示方法，包括 shell。

## 1.11. 键盘高级操作技巧

将要学习的命令：

1. clear     清空屏幕
2. history   显示历史列表内容

### 1.11.1. 命令行编辑

Bash使用一个名为Readline的库（共享的例程几何，可以被不同的程序使用），用以实现命令行编辑。

#### 1.11.1.1. 移动光标

* Ctrl-a      移动光标到行首
* Ctrl-e      移动光标到行尾
* Ctrl-f      光标前移一个字符；和右箭头作用一样。
* Ctrl-b      光标后移一个字符；和左箭头一样。
* Alt-f       光标前移一个字。
* Alt-f       光标前移一个字。
* Alt-b       光标后移一个字。
* Ctrl-l      清空屏幕，移动光标到左上角。clear命令完成同样的工作。

#### 1.11.1.2. 修改文本

* Ctrl-d      删除光标位置的字符。
* Ctrl-t      光标位置的字符和光标前面的字符互换位置。
* Alt-t       光标位置的字和其前面的字互换位置。
* Alt-l       把从光标位置到字尾的字符转换成小写字母。
* Alt-u       把从光标位置到字尾的字符转换成大写字母。

#### 1.11.1.3. 剪切和粘贴文本

Readline的文档使用术语killing和yanking来指我们平常所说的剪切和粘贴。剪切下来的本文被存储在一个叫做剪切环（kill-ring）的缓冲区中。

* Ctrl-k      剪切从光标位置到行为的文本。
* Ctrl-u      将剪切从光标位置到行首的文本。
* Alt-d       剪切从光标位置到词尾的文本。
* Alt-Backspace   剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。
* Ctrl-y      把剪切环中的文本粘贴到光标位置。

#### 1.11.1.4. 自动补全

shell能帮助你的另一种方式是通过一种叫做自动补全的机制。

* Alt-？       显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按项次tab键，这会更容易些。
* Alt-*       插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。

### 1.11.2. 利用历史命令

bash维护着一个已经执行过的命令的历史离别。这个命令列表被保存在你家目录下，一个名为.bash_history的文件里。

### 1.11.3. 搜索历史命令

history |grep /usr/bin    以及  !88

* 递增搜索    Ctrl-r  启动递增搜索，其后输入要寻找的文本。
* Ctrl-p      移动到上一个历史条目。类似于上箭头按键。
* Ctrl-n      移动到下一个历史条目。类似于下箭头按键。
* Alt-<       移动到历史列表开头
* Alt->       移动到历史列表结尾,即当前命令行.
* Ctrl-r      反向递增搜索.从当前命令行开始,向上递增搜索.
* Alt-p       反向搜索,非递增顺序.输入要查找的字符串,然后按下Enter,执行搜索.
* Alt-n       向前搜索,非递增顺序.
* Ctrl-o      执行历史列表中的当前项,并移到下一个.如果你想要执行历史列表中一系列的命令,这很方便.

### 1.11.4. 历史命令展开

* !number     重复历史列表中第number行的命令.
* !!          重复最后一次执行的命令.可能按下上箭头按键和enter键更容易.
* !string     重复最近历史列表中,以这个字符串开头的命令.
* !?string    重复最近历史列表中,包含这个字符串的命令.

## 1.12. 权限

### 1.12.1. 拥有者,组成员和其他人

id  用于查看当前用户的身份信息.用户账号自定义在/etc/passwd 文件中,用户组定义在/etc/group文件中.这些文件随着文件/etc/shadow的变动而修改.

### 1.12.2. 读取写入和执行

* \-   一个普通文件
* d    一个目录
* l    一个符号链接.注意对于符号链接文件,生于的文件属性总是"rwxrwxrwx",而且都是虚拟值.真正的文件属性是指符号链接所之乡的文件的属性.
* c    一个字符设备文件.这种文件类型是指按照字节流来处理数据的设备.比如说终端机或者调制解调器.
* b    一个块设备文件.这种文件类型是指按照数据块来处理数据的设备,例如一个硬盘或者CD-ROM盘.

剩下的九个字符叫做文件模式,代表着文件所有者\文件组所有者和其他人的读\写和执行权限.

* r    文件:允许打开并读取文件内容.
    目录:允许列出目录中的内容,前提是目录必须设置了可执行属性.
* w    文件:允许写入文件内容或截断文件.但是不允许对文件进行重命名或删除,重命名或删除是由目录的属性决定的.
    目录:允许在目录下新建\删除或重命名文件,前提是目录必须设置了可执行属性(x).
* x    文件:允许将文件作为程序来执行,使用脚本语言编写的程序必须设置为可读才能被执行.
    目录:允许进入目录,例如:cd directory.

### 1.12.3. chmod更改文件模式

只有文件的所有者或者超级用户才能更改文件或目录的模式.chmod命令支持两种不同的方法来改变文件模式:八进制数字表示法或符号表示法.
    八进制表示法:

* 0     000    ---
* 1     001    --x
* 2     010    -w-
* 3     011    -wx
* 4     100    r--
* 5     101    r-x
* 6     110    rw-
* 7     111    rwx
每个八进制数字代表了3个二进制数字,这种对应关系,正好映射到用来存储文件模式所使用的方案上.7(rwx),6(rw-),5(r-x),4(r--),0(---).八进制的7用二进制表示为111.

    符号表示法:

* u    "user"的简写,意思是文件或目录的所有者.
* g    "group"的简写.用户组
* o    "others""的简写,意思是其他所有的人.
* a    "all"的简写,是"u","g"和"o"的联合.

chmod符号表示法实例:

* u+x    为文件所有者添加可执行权限.
* u-x    删除文件所有者的可执行权限.
* +x     为文件所有者,用户组和其他所有人添加可执行权限.等价于a+x.
* o-rw   除了文件所有者和用户组,删除其他人的读权限和写权限.
* go=rw  给群组的主任和人以文件拥有着的人读写权限.如果群组的主人或全局之前已经有了执行的权限,他们将被移除.
* u+x,go=rw    给文件拥有着执行权限并给组和其他人读和执行的权限.多种设定可以用逗号分开.

### 1.12.4. umask设置默认权限

当创建一个文件时,umask命令控制着文件的默认权限.umask命令使用八进制表示法来表达从文件模式属性中删除一个位掩码.一个八进制的权限掩码用三位数字来表示,但是umask用四位数字来表示.这是因为除了读取,写入和执行权限之外,还有其他较少用到的权限设置.

setuid(八进制4000),当应用到一个可执行文件时,它把有效的用户ID从真正的用户设置成程序所有者ID.当一个普通用户运行一个程序,这个程序由根用户所有,并且设置了setuid位,这个程序运行时具有超级用户的特权,这样程序就可以访问普通用户禁止访问的文件和目录.

setgid位(八进制2000),把有效用户组ID从真正的用户组ID梗概为文件所有者的组ID.如果设置了一个目录的setgid位,则目录中新创建的文件具有这个目录用户组的所有权,而不是文件创建者所属用户组的所有权.

sticky位(八进制1000),他可以把一个可执行文件标志为"不可交换的".在linux中,会忽略文件的sticky位,但是如果一个目录设置了sticky位,那么它能组织用户删除或重命名文件,除非用户是这个目录的所有者或文件所有者,或超级用户.

* chmod u+s program    授予一个程序setuid权限
* chmod g+s dir        授予一个目录setgid权限
* chmod +t dir         授予一个目录sticky权限

### 1.12.5. 更改身份

    su    以其他用户身份和组ID运行一个shell
    sudo    以另一个用户身份执行命令

### 1.12.6. chown更改文件所有者和用户组

chown [owner][:[group]] file...

### 1.12.7. chgrp更改用户组所有权

chgrp [group] file...

### 1.12.8. 更改用户密码

passwd [user]

如果你具有超级用户权限,你可以指定一个用户名作为passwd命令的参数,这样可以设置另一个用户的密码.

## 1.13. 进程

### 1.13.1. 进程是怎样工作的

当系统启动的时候,内和先把一些它自己的活动初始化位进程,然后运行一个叫做init的程序.init,依次第,再运行一系列的称为init脚本的shell脚本(位于/etc),它们可以启动所有的系统服务.其中许多系统服务以守护(daemon)程序的形式实现,守护程序仅在后台运行,没有任何用户界面.

在进程方案中,一个程序可以发动另一个程序被表述位一个父进程可以产生一个子进程.

内核维护每个进程的信息,以此来保持事情有序.系统分配给每个进程一个数字,这个数字叫做进程ID或PID.PID号按升序分配,init进程的PID总是1.内和也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程.

### 1.13.2. 查看进程

* ps    命令查看进程

进程状态表

* R    运行中.
* S    正在睡眠.进程没有运行,而是正在等待一个事件.
* D    不可中断睡眠.进程正在等待I/O,例:一个磁盘驱动器的I/O
* T    已停止.已经指示进程停止运行.
* Z    一个死进程或"僵尸"进程.这是一个已经种植的紫禁城,但是它的父进程没有清空它.
* <    一个高优先级进程.这会授予一个进程更多重要的资源,给它更多的CPU时间.
* N    低优先级进程.
* ps x     展示所有进程
* ps aux   这个选项组合,能够显示属于每个用户的进程信息.此命令唤醒"BSD风格"的输出结果.

    BSD风格ps命令列标题

* USER    用户ID.进程的所有者.
* %CPU    以百分比表示的CPU使用率
* %MEM    以百分比表示的内存使用率
* VSZ      虚拟内存大小
* RSS      进程占用的物理内存的大小,以千字节位单位.
* START    进程启动的时间.若它的值超过24小时,则用天表示.

### 1.13.3. 用top命令动态查看进程

"top"这个名字来源于top程序是用来查看系统中"顶端"进程的.top显示结果由两部分组成:最上面是系统概要,下面是进程列表,以CPU的使用率排序.

top命令信息字段

    行号    字段            意义
    1     top            程序名
           14:59:20       当前时间.
           up 6:30        这是正常运行时间.
           2users         有两个用户登陆系统
           load average:  加载平均值,等待运行的进程数目.
    2     Tasks:         总结进程数目和这些进程的状态.
    3     Cpu(s):        这一行描述了CPU正在进行的活动特性.
           0.7%us         0.7%的CPU被用于用户进程.
           1.0%sy         1.0%的CPU时间被用于系统(内核)进程.
           0.0%ni         0.0%的CPU时间被用于"nice"(低优先级)进程.
           98.3%id        98.3%的CPU时间是空闲的.
           0.0%wa         0.0%的CPU时间来等待I/O.
    4     Mem:           展示物理内存的使用情况.
    5     Swap           展示交换分区(虚拟内存)的使用情况.

### 1.13.4. 控制进程

### 1.13.5. 中断一个进程

### 1.13.6. 把一个进程放置到后台执行

为了启动一个程序并让它立即在后台运行,我们在程序命令之后加上"&"字符.

### 1.13.7. 进程返回到前台

用jobs查看运行的人物,fg命令之后,跟随一个百分号和任务序号(jobspec)就可以了.

### 1.13.8. 停止一个进程

ctrl-z    可以停止一个进程,非终止它.

用bg命令把程序移到后台.

### 1.13.9. Signals

kill命令用来终止程序.

* kill [-signal] PID...	没有指定信号,默认发送TERM(终止)信号.

常用信号

* 1.HUP    挂起     当一个守护进程受到这个信号,会重新启动并读取配置文件.
* 2.INT    中断     实现和Ctrl-c一样的功能,由中断发送.通常会终止一个程序.
* 3.QUIT   退出
* 9.KILL   杀死     KILL信号从不被发送到目标程序,而是内核立即终止这个进程.
* 11.SEGV  段错误   如果一个程序非法使用内存,就会发送这个信号.
* 15.TERM  终止     如果程序仍然"或者",可以接受信号,那么这个会终止它.
* 18.CONT  继续     在一个停止信号后,这个信号会恢复进程的运行.
* 19.STOP  停止     这个信号导致进程停止运行,而不是终止.
* 20.TSTP  终端停止  当按下Ctrl-z组合键后,终端发送这个信号
* 28.WINCH 改变窗口大小  当改变窗口大小时,系统会发送这个信号.

    例:
    kill -9    13546
    kill -KILL 13546

### 1.13.10. 通过killall命令给多个进程发送信号

killall [-u user] [-signal] name...

### 1.13.11. 更多和进程相关的命令

* pstree  输出一个树型结构的进程列表.这个列表展示了进程见父/
子关系.
* vmstat  输出一个系统资源使用快照.包括内存,交换分区和磁盘I/O.
* xload   一个图形界面程序,可以划出系统负载随时间变化的图形.
* tload   与xload程序相似,但是在终端画出图形.

## 1.14. shell环境

* printenv   打印部分或所有的环境变量.
* set        设置shell选项
* export     导出环境变量,让随后执行的程序知道.
* alias      创建命令别名

### 1.14.1. 什么存储在环境变量中

* 环境变量
* shell变量

### 1.14.2. 检查环境变量

* set         显示shell和环境变量两者
* printenv    只显示环境变量
* alias       查看别名

### 1.14.3. 一些有趣的变量

* DISPLAY     通常为"0",意思是由X产生的第一个显示器.
* EDITOR      文本编辑器的名字.
* SHELL       shell程序的名字.
* HOME        用户家目录.
* LANG        定义了字符集以及语言编码方式.
* OLD_PWD     先前的工作目录.
* PAGER       页输出程序的名字.者经常设置为/usr/bin/less.
* PATH        由冒号分开的目录列表,当输入程序名后,会搜索这个目录列表.
* PS1         Prompt String 1.这个定义了你的shell提示符的内容.
* TERM        终端类型名.类Unix的系统支持许多终端协议;这个变量设置你的终端仿真器所用的协议.
* TZ          制定你所在的时区.
* USER        你的用户名.

### 1.14.4. 如何建立shell环境

shell会话类型:登陆shell会话;非登陆shell会话.

登陆shell会读取一个或多个启动文件.

    文件                 内容
    /etc/profile        应用于所有用户的全局配置脚本.
    ~/.bash_profile     用户私人的启动文件.可用来扩展或重写全局配置脚本中的设置.
    ~/.bash_login       如果文件~/.bash_profile没有找到.bash会尝试读取这个脚本.
    ~/.profile          如果~/.bash_profile或文件~/.bash_login都没有找到.bash会试图读取这个文件.这是基于Debian发行版的默认设置.

非登陆shell会话会读取以下启动文件:

    文件                 内容
    /etc/bash.bashrc    应用于所有用户的全局配置文件.
    ~/.bashrc           用户私有的启动文件.可以用来扩展或重写全局配置脚本中的设置.

### 1.14.5. 一个启动文件的内容

以"#"开头的行是注释,shell不会读取它们.

PATH变量经常在/etc/profile启动文件中设置.

### 1.14.6. 修改shell环境

### 1.14.7. 我们应该修改哪个文件

### 1.14.8. 文本编辑器

文本编辑器分为两种基本类型:图形化的和基于文本的编辑器.

### 1.14.9. 使用文本编辑器

nano    less vi 

### 1.14.10. 激活修改

source .bashrc  强迫bash重新读取修改过的.bashrc文件

## 1.15. vi简介

### 1.15.1. 学习vi

vi很多系统都预装.
vi是轻量级且执行快速的编辑器.

### 1.15.2. vi背景介绍

### 1.15.3. 启动和停止vi

* vi  启动vi
* :q  退出
* :q! 强制退出

### 1.15.4. 插入模式

i按键进入插入模式

### 1.15.5. 保存

:w  保存修改

### 1.15.6. 移动光标

* l or 右箭头         向右移动一个字符
* h or 左箭头         向左移动一个字符
* j or 下箭头         向下移动一行
* k or 上箭头         向上移动一行
* 0(按键)             移动到当前行的行首
* ^                  移动到当前行的第一个非空字符.
* $                  移动到当前行的末尾.
* w                   移动到下一个单词或标点符号的开头
* W                   移动到下一个单词的开头,忽略标点符号.
* b                   移动到上一个单词或标点符号的开头.
* B                   移动到上一个单词的开头,忽略标点符号
* Ctrl-f or Page Down 向下翻一页
* Ctrl-b or Page Up   向上翻一页
* numberG             移动到第number行.
* G                   移动到文件末尾.

### 1.15.7. 基本编辑

u按键       命令模式下会撤销卒后一次修改.

#### 1.15.7.1. 追加文本

a      命令模式下光标移动到行为.

#### 1.15.7.2. 打开一行

* o       当前行的下方打开一行.
* O       当前行的上方打开一行.

#### 1.15.7.3. 删除文本

* x       删除当前字符
* 3x      删除当前字符及气候的两个字符.
* dd      删除当前行
* 5dd     删除当前行及随后的四行文本.
* dW      删除从光标位置开始到下一个单词的开头.
* d$      从光标位置开始到当前行的行尾.
* d0      从光标位置开始到当前行的行首.
* d^      从光标位置开始到文本行的第一个非空字符.
* dG      从当前行到文件的末尾.
* d20G    从当前行到文件的第20行.

#### 1.15.7.4. 剪切,复制和粘贴文本

* d       删除的文本被复制到一个粘贴缓冲区
* p       将剪切板的文本粘贴到光标位置之后
* P       将剪切板中的文本粘贴到光标之前.
* yy      复制当前行.
* 5yy     复制当前行及随后的四行文本.
* yW      复制从当前光标位置到下一个单词的开头.
* y$      复制从当前光标位置到当前行的末尾.
* y0      复制从当前光标位置到行首.
* y^      复制从当前光标位置到文本行的第一个非空字符.
* yG      复制从当前行到文件末尾.
* y20G    复制从当前行到文件的第20行.

#### 1.15.7.5. 5

J       连接行与行.

### 1.15.8. 查找和替换

#### 1.15.8.1. 查找一行

f   查找一行,移动光标到下一个所制定的字符.

    例:fa   把光标定位到统一行中下一个出现的"a"字符.通过";"来重复这个查找.

#### 1.15.8.2. 查找整个文件

* /       移动光标到下一个出现的单词或短语上.通过n命令来重复先前的查找.
* /Line   把光标移动到文件的第一行.

#### 1.15.8.3. 全局查找和替代

:%s/Line/line/gc 把整个文件中的单词"Line"更改为"line"

* :       冒号字符运行一个ex命令
* %       指定要操作的行数.%是个快捷方式,表示从第一行到最后一行.
        1,5表示从第一行到第五行.
        1,$表示从第一行到文件的最后一行.
* s       指定操作.这种情况是,替换(查找与替代).
* /Line/line  查找类型与替代文本.
* g       全局的意思.意味着对文本行中所有匹配的字符串执行查找和替换操作.如果省略g,则只替换每个文本行中第一个匹配的字符串.
* c       指定一个需要用户确定的替换命令.
* y       执行替换操作
* n       跳过这个匹配的实例
* a       对这个及随后所有匹配的字符串执行替换操作.
* q or esc    退出替换操作.
* l       执行这次替换并退出.l是"last"简写.
* Ctrl-e,Ctrl-y   分别是向下滚动和向上滚动.用于查看建议替换的上下文.

### 1.15.9. 编辑多个文件

vi file1 file2 file3...

* :n          从一个文件转到下一个文件.
* :N          回到先前的文件.
* :buffers    会在屏幕顶部显示一个文件列表.
* :r file     把指定的文件插入到光标位置之前.

注意:在通过:n或:N命令再由:e命令加载的文件之间切换.这时要使用:buffer命令,气候加上缓冲区号码,来转换文件.

### 1.15.10. 保存工作

* ZZ          命令模式下输入ZZ就会保存并退出当前文件.
* :w filename 把文件另存为(文件名)

## 1.16. 自定制shell提示符

### 1.16.1. 解剖一个提示符

提示符包含我们的用户名,主机名和当前工作目录.它是由一个环境变量定义的,叫做PS1(prompt string one),可通过echo命令来查看PS1的内容.

    [me@linuxbox ~]$ echo $PS1
    [\u@\h \W]\$
* \a      以ASCII格式编码的铃声.当遇到这个转义序列时,计算机会发出嗡嗡的响声.
* \d      以日,月,天格式来表示当前日期.
* \h      本地机的主机名,但不代末尾的域名.
* \H      完整的主机名.
* \j      运行在当前shell会话中的工作数.
* \l      当前终端设备名.
* \n      一个换行符.
* \r      一个回车符.
* \s      shell程序名.
* \t      以24小时制,hours:minutes:seconds的格式表示当前时间.
* \T      以12小时制表示当前时间.
* \@      以12小时制,AM/PM格式来显示当前时间.
* \A      以24小时制,hours:minutes格式表示当前时间.
* \u      当前用户名.
* \v      shell程序的版本号.
* \V      shell程序的版本号.
* \w      当前工作目录名.
* \W      当前工作目录名的最后部分.
* \\!      当前命令的历史号.
* \\#      当前shell绘画中的命令数.
* \\\$      这会显示一个"$"字符,除非你拥有超级用户权限.
* \\[      标志着一系列一个或多个非打印字符的开始.被用来潜入非打印的控制字符,这些字符以某种方式来操作终端仿真器,比如说移动光标或者是更改文本颜色.
* \\]      标志着非打印字符序列结束.

### 1.16.2. 一些可替代的提示符设计

* ps1_old="$PS1"  备份变量
* PS1="[\u@\h@\s\n\t \W \$]"  编辑变量PS1
* PS1="$ps1_old"

### 1.16.3. 添加颜色

字符颜色是由发送到终端仿真器的一个嵌入到了要显示的字符流中的 ANSI 转义编码来控制的。这个控制编码不会“打印”到屏幕上,而是被终端解释为一个指令。'[' 和 ']' 序列被用来封装这些非打印字符。一个 ANSI 转义编码以一个八进制 033(这个编码是由退出按键产生的)开头,其后跟着一个可选的字符属性,在之后是一个指令。

* \033[0;30m]      Black       \033[1;30m]      Dark Gray
* \033[0;31m]      Red         \033[1;31m]      Light Red
* \033[0;32m]      Green       \033[1;32m]      Light Green
* \033[0;33m]      Brown       \033[1;33m]      Yellow
* \033[0;34m]      Blue        \033[1;34m]      Light Blue
* \033[0;35m]      Purple      \033[1;35m]      Light Pur-ple
* \033[0;36m]      Cyan        \033[1;36m]      Light Cyan
* \033[0;37m ]     Light Gray  \033[1;37m]      White

    例:PS1="[\033[0;31m\]<\u@\h@\s\n\t \W \\$\033[0m"

用转义序列来设置背景颜色

* \033[0;40m 蓝色 \033[1;44m 黑色
* \033[0;41m 红色 \033[1;45m 粉红
* \033[0;42m 绿色 \033[1;46m 青色
* \033[0;43m 棕色 \033[1;47m 浅灰色

    例:PS1='\\[\033[0;41m\\]<\u@\h \W>\$\\[\033[0m\\] '
    注意:除了正常的 (0) 和黑体 (1) 字符属性之外,文本也可以具有下划线 (4),闪烁 (5),和反向 (7) 属性。为了拥有好品味,然而,许多终端仿真器拒绝使用这个闪烁属性。

### 1.16.4. 移动光标

* \033[1;cH    把光标移动第一行,第C列.
* \033[nA      把光标向上移动n行.
* \033[nB      把光标向下移动n行.
* \033[nC      把光标向前移动n个字符.
* \033[nD      把光标向后移动n个字符.
* \033[2J      清空屏幕,把光标移到左上角(第0行,第0列).
* \033[K       清空从光标位置到当前行末的内容.
* \033[s       存储当前光标位置.
* \033[u       唤醒之前存储的光标位置.

    例:PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]
<\u@\h \W>\$ '

    \[          开始一个非打印字符序列.其真正的目的是为了让bash能够正确第计算提示符的大小.如果没有这个转义字符的话,命令行编辑功能会弄错光标的位置.
    \033[s      存储光标位置.这个用来使光标能回到原来提示符的位置.当长条和时钟显示到屏幕上方之后.当心一些终端仿真器不推崇这个编码.
    \033[0;0H   把光标移到屏幕左上角,也就是第0行,第0列的位置.
    \033[0;41m  把背景设置为红色.
    \033[1;33m  把文本颜色设为黄色.
    \t          显示当前时间.虽然这是一个可"打印"的元素,但我们仍把它包含在提示符的非打印部分,因为我们不想bash在计算可见提示符的真正大小时包含这个时钟在内.
    \033[0m     关闭颜色设置.这对文本和背景都起作用.
    \033[u      恢复到之前保存过的光标位置处.
    \]          结束非打印字符序列.
    <\u@\h\W>\$ 提示符字符串.

### 1.16.5. 保存提示符

    PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ '

## 1.17. 软件包管理

Linux发行版本质量最重要的决定因素是软件包管理系统和其支持社区的持久性.

### 1.17.1. 打包系统

* Debian Style(.deb)  Debian,Ubuntu,Xandros,Linspire
* Red Hat Style(.rpm) Fedora,Centos,Red Hat Enterprise Linux,OpenSUSE,Mandriva,PCLinuxOS

### 1.17.2. 软件包管理系统工作原理

### 1.17.3. 包文件

包文件是一个构成软件包的文件压缩集合.一个软件包可能由大量程序以及支持这些程序的数据文件组成.另外,许多软件包还包含预安装和安装后脚本.

### 1.17.4. 资源库

软件项目选择执行他们自己的打包和发布策略,但是现在大多数软件包是由发行
商和感兴趣的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包,这
个资源库可能包含了成千上万个软件包,每一个软件包都是专门为这个系统发行版建立和维护
的。

### 1.17.5. 依赖性

程序很少是"孤立的",而是依赖于其它软件组件来完成它们的工作.

### 1.17.6. 上层和底层软件包工具

软件包管理系统通常由两种工具类型组成:

* 底层工具用来处理这些任务,如安装和删除软件包文件.
* 上层工具用来完成元数据搜索和依赖解析.

### 1.17.7. 常见软件包管理任务

### 1.17.8. 查找资源库中的软件包

使用上层工具来搜索资源库元数据,可以根据软件包的名字和说明来定位它.

    风格        命令
    Debian     apt-get update;apt-cache search search_string
    Red Hat    dnf search search_string

    例:dnf search emacs  通过dnf资源库来查找emacs文本编辑器.

### 1.17.9. 从资源库中安装一个软件包

上层工具允许从一个资源库中下载一个软件包,并经过完全依赖解析来安装它.

### 1.17.10. 通过软件包文件来安装软件

如果从某处而不是从资源库中下载了一个软件包文件,可以使用底层工具来直接(没有经过依赖解析)安装它.

底层软件包安装命令

    风格       命令
    Debian    dpkg --install package_file
    Red Hat   rpm -i package_file

注意:因为这项技术使用底层的rpm程序来执行安装任务,所以没有运行依赖解析.如果rpm程序发现缺少了一个依赖,则会报错并退出.

### 1.17.11. 卸载软件

可以使用上层或者底层工具来卸载软件.

上层工具卸载命令:

    风格      命令
    Debian   apt-get remove package_name
    Red Hat  yum erase package_name

### 1.17.12. 经过资源库来更新软件包

软件包更新命令

    风格      命令
    Debian   apt-get update;apt-get upgrade
    Red Hat  yum update

### 1.17.13. 经过软件包文件来升级软件

可以安装非资源库网站下载的软件包最新版,用它来替代先前的版本.

底层软件包升级命令
    风格        命令
    Debian     dpkg --install package_file
    Red Hat    rpm -U package_file

    例:rpm -U emacs-22.1-7.fc7-i386.rpm

注意:rpm程序安装一个软件包和升级一个软件包所用的选项是不同的,而dpkg程序所用的选项是相同的.

### 1.17.14 列出所安装的软件包

    风格         命令
    Debian      dpkg --list
    Red Hat     rpm -qa

### 1.17.15 确定是否安装了一个软件包

软件包状态命令
    风格           命令
    Debian        dpkg --status package_name
    Red Hat       rpm -q package_name

### 1.17.16 显示所安装软件包的信息

查看软件包信息命令
    风格          命令
    Debian       apt-cache show package_name
    Red Hat      yum info package_name

### 1.17.17 查找安装了某个文件的软件

包文件识别命令

风格          命令
Debian       dpkg --search file_name
Red Hat      rpm -qf file_name

## 1.18 存储媒介

* mount    挂载一个文件系统
* umount   卸载一个文件系统
* fsck     检查和修复一个文件系统
* fdisk    分区表控制器
* mkfs     创建文件系统
* fdformat 格式化一张软盘
* dd       把面向块的数据直接写入设备
* genisoimage(mksiofs)    创建一个ISO 9660 的映像文件
* wodim(cdrecord)    把数据写入光存储媒介
* md5sum    计算MD5检验码

