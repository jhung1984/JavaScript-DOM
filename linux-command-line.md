##什么是shell
	shell是一个程序，它接受从键盘输入的命令，然后把命令传递给操作系统去执行。
	bash是来自GNU项目的shell程序。
	bash是“Bourne Again Shell”的首字母缩写。
	bash是最初Unix上由Steve Bourne写成shell程序sh的增强版。
##shell技巧
	移动光标：借助上箭头按键获得上次输入的命令。
		   借助左右按键把光标定位到命令行的任意位置。
	tab：tab按键具有文件/目录/命令的补全功能。
##shell命令
	date	日期
	cal	日历
	df	查看磁盘剩余空间。
	free	查看空闲内存。
	exit	退出shell。
	pwd	打印当前目录名。
	ls	列出目录内容
	.	指工作目录
	..	指工作目录的父目录
	cd	更改目录
	cd -	更改目录到先前的目录
	cd ~user_name	更改工作目录到用户家目录.
	注:linux对大小写敏感且没有文件扩展名的概念.文件名支持标点符号仅限使用"."和"-"及"_".
    file    当调用file命令后，file命令会打印出文件内容的简单描述。
    less    用来浏览文本文件的程序.
##linux系统中的目录
    /       根目录,万物之源.
    /bin    包含系统启动和运行所必须的二进制程序.
    /boot   包含Linux内核,最初的RMA磁盘映像和启动加载程序.
        /boot/grub/grub.conf or menu.lst,用来配置启动加载程序.
        /boot/vmlinuz,linux内核
    /dev    包含设备节点的特殊目录."一切皆是文件",也适用于设备.内核维护着它的支持设备.
    /etc    包含所有系统层面的配置文件.同时也包含一系列的shell脚本,在系统启动时,这些脚本会运行每个系统服务.这个目录中的任何文件都应该是可读文本文件.
        /etc/crontab,定义自动运行的任务.
        /etc/fstab,包含存储设备的列表及相关挂载点.
        /etc/passwd,包含用户账号列表.
    /home   系统会在/home下,为每个用户分配一个工作目录.
    /lib    包含核心系统程序所需的库文件.类似windows中的动态链接库.
    /lost+found 每个使用linux文件系统的格式化分区或设备,都会有这个目录.当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录是空的，除非文件系统损坏。
    /media    包含可移动介质的挂载点。
    /mnt    早些的系统中，/mnt目录包含可以东介质的挂载点。
    /opt    用来安装“可选”软件。用来存储可能安装在系统中的商业软件产品。
    /proc   是一个由Linux内核维护的虚拟文件系统。它包含的文件是内核的窥视孔。这些可读的文件告诉你内核是怎样监管你的计算机的。
    /root   root账户的家目录。
    /sbin   包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。
    /tmp    用来存储由各种程序创建的临时文件的地方。
    /usr    包含普通用户所需要的所有程序和文件。
        /usr/bin    包含系统安装的执行程序。
        /usr/lib    包含/usr/bin目录中的程序所用的共享库。
        /usr/local  非系统发行版自带程序的安装目录。通常由源码编译的程序会安装在/usr/local/bin目录下。
        /usr/sbin   包含许多系统管理程序。
        /usr/share  包含许多由/usr/bin目录中的程序使用的共享数据。其中包括默认的配置文件、图表、桌面北京、音频文件等等。
        /usr/share/doc  包含安装在系统中的软件包的文档。
    /var    存放的是动态文件。各种数据库，假脱机文件，用户邮件等等。
        /var/log    包含日至文件、各种系统活动的记录。其中/var/log/messages很重要。
##符号链接
    创建硬链接   ln  当创建文件硬链接，实际是为文件创建了额外的名字部分，并且名字关联到相同的数据部分。硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。
    创建符号链接   ln -s  创建符号链接既可以使用绝对路径也可以使用相对路径名。符号链接可以关联目录。
#命令的使用
    命令的四种形式：
        1.可执行程序.
        2.内建于shell自身的命令.
        3.shell函数.
        4.命令别名.自定义自己的命令,尖子在其他命令之上.
##命令的识别
    type    type command    shell的内部命令,它会显示命令的类别.
    which   确定所执行程序的准确位置.只对可执行程序有效,不包括内建命令和命令别名.
##命令的文档
    help    得到shell内建命令的帮助文档.bash有一个内建的帮助工具.
        --help  很多执行程序支持一个--help选项,这个想象是显示命令所支持的语法和选项说明.
    man     man program(program是要浏览的命令名)     显示程序手册页.许多可执行程序提供了一个正式的文档,叫做手册页(man page).
    apropos 显示适当的命令.
        注意:man命令加上"-k"选项与apropos完成一样的功能.
    whatis  显示非常简介的命令说明.
    info    显示程序Info条目.GNU项目提供了一个命令程序手册页的替代五,称其为"info"
    README和其它程序文档   位于/usr/share/doc目录下的文本文件,可用less阅读器来浏览.以".gz"结尾的文件是用gzip压缩程序压缩的.gzip软件包包含了一个特殊的less版本,叫做zless,可以显示由gzip压缩的文本文件内容.
##重定向
    I/O重定向."I/O"代表输入/输出,通过此工具可以重定向命令的输入输出,命令输入输出均来自文件.也可以把多个命令联结起来组成强大的命令管道.
    ###shell命令
        cat     连接文件.
                例:cat movie.mpeg.0* > movie.mpeg    因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。
        sort    排序文本行
        uniq    报道或省略重复行
        grep    打印匹配行
        wc      打印文件中换行符,字和字节个数.
        head    输出文件第一部分
        tail    输出文件最后一部分
        tee     从标准输入读取数据并写道标准输出和文件.
    许多程序都会产生某种输出.经常由两种类型组成.
        1.  程序运行结果.
        2.  状态和错误信息.
    I/O重定向允许我们梗概输出地点和输入来源.一般输入来自键盘,输出送到屏幕.通过I/O重定向,我们可以改变.
    shell将文件流的前三个称作标准输入,标准输出和错误,称为表述副0,1,2.
    ###标准输出重定向
        >   > filename  将标准输出重定向到除屏幕意外的另一个文件.
                例:ls -l /bin/usr > ls-output.txt
                > text.txt  没有命令在它之前,这回清空同名的文件内容或创建空文件.
            >> filename 将重定向结果追加到文件内容豁后面.
    ###标准错误重定向
        例:ls -l /bin/usr 2>ls-error.txt 文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务。
        ####重定向标准输出和错误到同一文件
            方法一:
            例:ls -l /bin/usr > ls-output.txt 2>&1   首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2>&1。重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。
            方法二:
            例:ls -l /bin/usr &> ls-output.txt   用单单一个表示法 &> 来重定向标准输出和错误到文件 ls-output.txt。
        ####处理不需要的输出
            系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。
            例:ls -l /bin/usr 2> /dev/null
    ###标准输入重定向
        例:cat > lazy_dog.txt
           The quick brown fox jumped over the lazy dog.
        输入命令，其后输入要放入文件中的文本。输入 Ctrl-d（按住 Ctrl 键同时按下”d”），来告诉 cat，在标准输入中， 它已经到达文件末尾（EOF）.通过使用这个命令，我们 实现了世界上最低能的文字处理器！
        例:cat < lazy_dog.txt
        使用"<"重定向操作符,把标准输入源从键盘改到文件lazy_dog.txt.
        ####管道线
            |    command1 | command2    使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入.
                例:ls -l /usr/bin | less
        ####过滤器
            管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。
                例:ls /bin /usr/bin | sort | less    因为我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个 有序列表。
        ####uniq    报道或忽略重复行
            默认情况下，从数据列表中删除任何重复行。uniq 命令经常和 sort 命令结合在一起使用。
                例:ls /bin /usr/bin | sort | uniq | less     使用 uniq 从 sort 命令的输出结果中，来删除任何重复行。如果我们想看到 重复的数据列表，让 uniq 命令带上”-d”选项.
        ###wc   打印行数,字数和字节数
            wc命令是用来显示文件所包含的行数,字数和字节数.它接受标准输入。”-l”选项限制命令输出只能 报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。
        ###grep grep pattern [file...]  打印匹配行
            用来找到文件中的匹配文本。grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。
        ###head / tail － 打印文件开头部分/结尾部分.
            head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。
            tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为 它们同时在被写入。使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。
        ###tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件
            tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。
            例:ls /usr/bin | tee ls.txt | grep zip   在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt.
##从shell眼中看世界
        ###字符展开
            echo    显示一行文本。传递到 echo 命令的任一个参数都会在（屏幕上）显示出来。
            echo *  ”*“字符意味着匹配文件名中的任意字符，shell 在 echo 命 令被执行前把”*“展开成了另外的东西（在这里，就是在当前工作目录下的文件名字）。
        ###路径名展开
            echo ls -d .[!.]?*  这种模式展开成所有以圆点开头，第二个字符不包含圆点，再包含至少一个字符， 并且这个字符之后紧接着任意多个字符的文件名。这个命令将正确列出大多数的隐藏文件 （但仍不能包含以多个圆点开头的文件名）。带有 -A 选项（“几乎所有”）的 ls 命令能够提供一份正确的隐藏文件清单：ls -A
        ###波浪线展开
            

-----------------------------------------------------------------------------------------------------------------
##键盘高级操作技巧
        将要学习的命令：
            1、clear     清空屏幕
            2、history   显示历史列表内容
    ###命令行编辑
        Bash使用一个名为Readline的库（共享的例程几何，可以被不同的程序使用），用以实现命令行编辑。
        ####移动光标
            Ctrl-a      移动光标到行首
            Ctrl-e      移动光标到行尾
            Ctrl-f      光标前移一个字符；和右箭头作用一样。
            Ctrl-b      光标后移一个字符；和左箭头一样。
            Alt-f       光标前移一个字。
            Alt-f       光标前移一个字。
            Alt-b       光标后移一个字。
            Ctrl-l      清空屏幕，移动光标到左上角。clear命令完成同样的工作。
        ####修改文本
            Ctrl-d      删除光标位置的字符。
            Ctrl-t      光标位置的字符和光标前面的字符互换位置。
            Alt-t       光标位置的字和其前面的字互换位置。
            Alt-l       把从光标位置到字尾的字符转换成小写字母。
            Alt-u       把从光标位置到字尾的字符转换成大写字母。
        ####剪切和粘贴文本
            Readline的文档使用术语killing和yanking来指我们平常所说的剪切和粘贴。剪切下来的本文被存储在一个叫做剪切环（kill-ring）的缓冲区中。
            Ctrl-k      剪切从光标位置到行为的文本。
            Ctrl-u      将剪切从光标位置到行首的文本。
            Alt-d       剪切从光标位置到词尾的文本。
            Alt-Backspace   剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。
            Ctrl-y      把剪切环中的文本粘贴到光标位置。
        ####自动补全
            shell能帮助你的另一种方式是通过一种叫做自动补全的机制。
                Alt-？       显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按项次tab键，这会更容易些。
                Alt-*       插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。
        ###利用历史命令
            bash维护着一个已经执行过的命令的历史离别。这个命令列表被保存在你家目录下，一个名为.bash_history的文件里。
        ###搜索历史命令
            history |grep /usr/bin    以及  !88
            递增搜索    Ctrl-r  启动递增搜索，其后输入要寻找的文本。
            Ctrl-p      移动到上一个历史条目。类似于上箭头按键。
            Ctrl-n      移动到下一个历史条目。类似于下箭头按键。
            Alt-<       移动到历史列表开头
            Alt->       移动到历史列表结尾,即当前命令行.
            Ctrl-r      反向递增搜索.从当前命令行开始,向上递增搜索.
            Alt-p       反向搜索,非递增顺序.输入要查找的字符串,然后按下Enter,执行搜索.
            Alt-n       向前搜索,非递增顺序.
            Ctrl-o      执行历史列表中的当前项,并移到下一个.如果你想要执行历史列表中一系列的命令,这很方便.
        ###历史命令展开
            !number     重复历史列表中第number行的命令.
            !!          重复最后一次执行的命令.可能按下上箭头按键和enter键更容易.
            !string     重复最近历史列表中,以这个字符串开头的命令.
            !?string    重复最近历史列表中,包含这个字符串的命令.
##权限
    ###拥有着,组成员和其他人
        id  用于查看当前用户的身份信息.用户账号自定义在/etc/passwd 文件中,用户组定义在/etc/group文件中.这些文件随着文件/etc/shadow的变动而修改.
